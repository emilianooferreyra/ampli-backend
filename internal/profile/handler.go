package profile

import (
	"context"
	"net/http"
	"strconv"
	"time"

	"ampli/api/internal/middleware"
	"ampli/api/internal/models"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type Handler struct {
	db *mongo.Database
}

func NewHandler(db *mongo.Database) *Handler {
	return &Handler{db: db}
}

func (h *Handler) RegisterRoutes(r *gin.Engine, auth *middleware.Auth) {
	g := r.Group("/profile")

	// Public routes
	g.GET("/:profileId", h.GetPublicProfile)
	g.GET("/:profileId/uploads", h.GetPublicUploads)
	g.GET("/:profileId/playlist", h.GetPublicPlaylist)
	g.GET("/:profileId/followers", h.GetFollowerProfilePublic)

	// Authenticated routes
	authenticated := g.Group("")
	authenticated.Use(auth.RequireAuth())
	authenticated.POST("/:profileId/follow", h.UpdateFollower)
	authenticated.GET("/:profileId/is-following", h.GetIsFollowing)
	authenticated.GET("/uploads", h.GetUploads)
	authenticated.GET("/playlists", h.GetAutoGeneratedPlaylist)
	authenticated.GET("/followers", h.GetFollowersProfile)
	authenticated.GET("/followings", h.GetFollowingsProfile)
	authenticated.GET("/recommended", h.GetRecommendByProfile)
}

// UpdateFollower toggles follow/unfollow for a profile.
// POST /profile/:profileId/follow
func (h *Handler) UpdateFollower(c *gin.Context) {
	profileIDStr := c.Param("profileId")
	profileID, err := primitive.ObjectIDFromHex(profileIDStr)
	if err != nil {
		c.JSON(http.StatusUnprocessableEntity, gin.H{"error": "Invalid profile id!"})
		return
	}

	profile := middleware.GetUser(c)
	userID, _ := primitive.ObjectIDFromHex(profile.ID)

	ctx, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
	defer cancel()

	users := h.db.Collection(models.UsersCollection)

	// Check target profile exists
	count, _ := users.CountDocuments(ctx, bson.M{"_id": profileID})
	if count == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Profile not found!"})
		return
	}

	// Check already following
	alreadyFollowing, _ := users.CountDocuments(ctx, bson.M{"_id": profileID, "followers": userID})

	var status string
	if alreadyFollowing > 0 {
		users.UpdateOne(ctx, bson.M{"_id": profileID}, bson.M{"$pull": bson.M{"followers": userID}})    //nolint:errcheck
		users.UpdateOne(ctx, bson.M{"_id": userID}, bson.M{"$pull": bson.M{"followings": profileID}})   //nolint:errcheck
		status = "removed"
	} else {
		users.UpdateOne(ctx, bson.M{"_id": profileID}, bson.M{"$addToSet": bson.M{"followers": userID}})  //nolint:errcheck
		users.UpdateOne(ctx, bson.M{"_id": userID}, bson.M{"$addToSet": bson.M{"followings": profileID}}) //nolint:errcheck
		status = "added"
	}

	c.JSON(http.StatusOK, gin.H{"status": status})
}

// GetUploads returns the authenticated user's own uploads (paginated).
// GET /profile/uploads
func (h *Handler) GetUploads(c *gin.Context) {
	profile := middleware.GetUser(c)
	ownerID, _ := primitive.ObjectIDFromHex(profile.ID)

	skip, limit := parsePagination(c)

	ctx, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
	defer cancel()

	opts := options.Find().
		SetSkip(skip).
		SetLimit(limit).
		SetSort(bson.D{{Key: "createdAt", Value: -1}})

	cursor, err := h.db.Collection(models.AudiosCollection).Find(ctx, bson.M{"owner": ownerID}, opts)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch uploads"})
		return
	}
	defer cursor.Close(ctx)

	var items []models.Audio
	cursor.All(ctx, &items) //nolint:errcheck

	audios := make([]gin.H, 0, len(items))
	for _, a := range items {
		posterURL := ""
		if a.Poster != nil {
			posterURL = a.Poster.URL
		}
		audios = append(audios, gin.H{
			"id":       a.ID.Hex(),
			"title":    a.Title,
			"about":    a.About,
			"file":     a.File.URL,
			"category": a.Category,
			"poster":   posterURL,
			"date":     a.CreatedAt,
			"owner":    gin.H{"name": profile.Name, "id": profile.ID},
		})
	}
	c.JSON(http.StatusOK, gin.H{"audios": audios})
}

// GetPublicUploads returns a user's uploads visible to everyone.
// GET /profile/:profileId/uploads
func (h *Handler) GetPublicUploads(c *gin.Context) {
	profileIDStr := c.Param("profileId")
	profileID, err := primitive.ObjectIDFromHex(profileIDStr)
	if err != nil {
		c.JSON(http.StatusUnprocessableEntity, gin.H{"error": "Invalid profile id!"})
		return
	}

	skip, limit := parsePagination(c)

	ctx, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
	defer cancel()

	pipeline := mongo.Pipeline{
		{{Key: "$match", Value: bson.D{{Key: "owner", Value: profileID}}}},
		{{Key: "$sort", Value: bson.D{{Key: "createdAt", Value: -1}}}},
		{{Key: "$skip", Value: skip}},
		{{Key: "$limit", Value: limit}},
		{{Key: "$lookup", Value: bson.D{
			{Key: "from", Value: "users"},
			{Key: "localField", Value: "owner"},
			{Key: "foreignField", Value: "_id"},
			{Key: "as", Value: "ownerData"},
		}}},
		{{Key: "$unwind", Value: "$ownerData"}},
		{{Key: "$project", Value: bson.D{
			{Key: "_id", Value: 0},
			{Key: "id", Value: "$_id"},
			{Key: "title", Value: 1},
			{Key: "about", Value: 1},
			{Key: "file", Value: "$file.url"},
			{Key: "poster", Value: "$poster.url"},
			{Key: "date", Value: "$createdAt"},
			{Key: "owner", Value: bson.D{
				{Key: "name", Value: "$ownerData.name"},
				{Key: "id", Value: "$ownerData._id"},
			}},
		}}},
	}

	cursor, err := h.db.Collection(models.AudiosCollection).Aggregate(ctx, pipeline)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch uploads"})
		return
	}
	defer cursor.Close(ctx)

	var audios []bson.M
	cursor.All(ctx, &audios) //nolint:errcheck
	if audios == nil {
		audios = []bson.M{}
	}
	c.JSON(http.StatusOK, gin.H{"audios": audios})
}

// GetPublicProfile returns basic profile info for any user.
// GET /profile/:profileId
func (h *Handler) GetPublicProfile(c *gin.Context) {
	profileIDStr := c.Param("profileId")
	profileID, err := primitive.ObjectIDFromHex(profileIDStr)
	if err != nil {
		c.JSON(http.StatusUnprocessableEntity, gin.H{"error": "Invalid profile id!"})
		return
	}

	ctx, cancel := context.WithTimeout(c.Request.Context(), 5*time.Second)
	defer cancel()

	var user models.User
	if err := h.db.Collection(models.UsersCollection).FindOne(ctx, bson.M{"_id": profileID}).Decode(&user); err != nil {
		c.JSON(http.StatusUnprocessableEntity, gin.H{"error": "User not found!"})
		return
	}

	avatarURL := ""
	if user.Avatar != nil {
		avatarURL = user.Avatar.URL
	}

	c.JSON(http.StatusOK, gin.H{
		"profile": gin.H{
			"id":        user.ID.Hex(),
			"name":      user.Name,
			"followers": len(user.Followers),
			"avatar":    avatarURL,
		},
	})
}

// GetPublicPlaylist returns a user's public playlists.
// GET /profile/:profileId/playlist
func (h *Handler) GetPublicPlaylist(c *gin.Context) {
	profileIDStr := c.Param("profileId")
	profileID, err := primitive.ObjectIDFromHex(profileIDStr)
	if err != nil {
		c.JSON(http.StatusUnprocessableEntity, gin.H{"error": "Invalid profile id!"})
		return
	}

	skip, limit := parsePagination(c)

	ctx, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
	defer cancel()

	opts := options.Find().
		SetSkip(skip).
		SetLimit(limit).
		SetSort(bson.D{{Key: "createdAt", Value: -1}})

	cursor, err := h.db.Collection(models.PlaylistsCollection).Find(ctx,
		bson.M{"owner": profileID, "visibility": "public"},
		opts,
	)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch playlists"})
		return
	}
	defer cursor.Close(ctx)

	var items []models.Playlist
	cursor.All(ctx, &items) //nolint:errcheck

	result := make([]gin.H, 0, len(items))
	for _, pl := range items {
		result = append(result, gin.H{
			"id":         pl.ID.Hex(),
			"title":      pl.Title,
			"itemsCount": len(pl.Items),
			"visibility": pl.Visibility,
		})
	}
	c.JSON(http.StatusOK, gin.H{"playlist": result})
}

// GetAutoGeneratedPlaylist returns Mix20 + category-based auto playlists for the user.
// GET /profile/playlists
func (h *Handler) GetAutoGeneratedPlaylist(c *gin.Context) {
	profile := middleware.GetUser(c)
	ownerID, _ := primitive.ObjectIDFromHex(profile.ID)

	ctx, cancel := context.WithTimeout(c.Request.Context(), 15*time.Second)
	defer cancel()

	// Build Mix20 from listening history
	mix20Pipeline := mongo.Pipeline{
		{{Key: "$match", Value: bson.D{{Key: "owner", Value: ownerID}}}},
		{{Key: "$unwind", Value: "$all"}},
		{{Key: "$group", Value: bson.D{
			{Key: "_id", Value: "$all.audio"},
			{Key: "items", Value: bson.D{{Key: "$addToSet", Value: "$all.audio"}}},
		}}},
		{{Key: "$sample", Value: bson.D{{Key: "size", Value: 20}}}},
		{{Key: "$group", Value: bson.D{
			{Key: "_id", Value: nil},
			{Key: "items", Value: bson.D{{Key: "$push", Value: "$_id"}}},
		}}},
	}

	cursor, _ := h.db.Collection(models.HistoriesCollection).Aggregate(ctx, mix20Pipeline)
	var mix20Results []bson.M
	if cursor != nil {
		cursor.All(ctx, &mix20Results) //nolint:errcheck
		cursor.Close(ctx)
	}

	const mix20Title = "Mix20"
	if len(mix20Results) > 0 {
		h.db.Collection(models.PlaylistsCollection).UpdateOne(ctx, //nolint:errcheck
			bson.M{"owner": ownerID, "title": mix20Title},
			bson.M{"$set": bson.M{"title": mix20Title, "items": mix20Results[0]["items"], "visibility": "auto"}},
			options.Update().SetUpsert(true),
		)
	}

	// Get user's listening categories from last 30 days
	categories := h.getUserCategories(ctx, ownerID)

	// Sample 4 auto-generated playlists matching user's categories
	agplMatch := bson.D{{Key: "_id", Value: bson.D{{Key: "$exists", Value: true}}}}
	if len(categories) > 0 {
		agplMatch = bson.D{{Key: "title", Value: bson.D{{Key: "$in", Value: categories}}}}
	}

	agplPipeline := mongo.Pipeline{
		{{Key: "$match", Value: agplMatch}},
		{{Key: "$sample", Value: bson.D{{Key: "size", Value: 4}}}},
		{{Key: "$project", Value: bson.D{
			{Key: "_id", Value: 0},
			{Key: "id", Value: "$_id"},
			{Key: "title", Value: 1},
			{Key: "itemsCount", Value: bson.D{{Key: "$size", Value: "$items"}}},
		}}},
	}

	cursor, _ = h.db.Collection(models.AutoGeneratedPlaylistsCollection).Aggregate(ctx, agplPipeline)
	var agpl []bson.M
	if cursor != nil {
		cursor.All(ctx, &agpl) //nolint:errcheck
		cursor.Close(ctx)
	}

	// Append the user's own Mix20 playlist
	var mix20Playlist models.Playlist
	h.db.Collection(models.PlaylistsCollection).FindOne(ctx, bson.M{"owner": ownerID, "title": mix20Title}).Decode(&mix20Playlist) //nolint:errcheck

	finalList := append(agpl, bson.M{
		"id":         mix20Playlist.ID.Hex(),
		"title":      mix20Playlist.Title,
		"itemsCount": len(mix20Playlist.Items),
	})

	c.JSON(http.StatusOK, gin.H{"playlist": finalList})
}

// GetFollowersProfile returns the current user's followers (paginated).
// GET /profile/followers
func (h *Handler) GetFollowersProfile(c *gin.Context) {
	profile := middleware.GetUser(c)
	ownerID, _ := primitive.ObjectIDFromHex(profile.ID)
	limit, page := parseRawPagination(c)

	c.JSON(http.StatusOK, gin.H{"followers": h.fetchFollowersAggregate(c.Request.Context(), ownerID, limit, page, "followers")})
}

// GetFollowerProfilePublic returns a public user's followers.
// GET /profile/:profileId/followers
func (h *Handler) GetFollowerProfilePublic(c *gin.Context) {
	profileIDStr := c.Param("profileId")
	profileID, err := primitive.ObjectIDFromHex(profileIDStr)
	if err != nil {
		c.JSON(http.StatusUnprocessableEntity, gin.H{"error": "Invalid profile id!"})
		return
	}
	limit, page := parseRawPagination(c)
	c.JSON(http.StatusOK, gin.H{"followers": h.fetchFollowersAggregate(c.Request.Context(), profileID, limit, page, "followers")})
}

// GetFollowingsProfile returns the current user's followings.
// GET /profile/followings
func (h *Handler) GetFollowingsProfile(c *gin.Context) {
	profile := middleware.GetUser(c)
	ownerID, _ := primitive.ObjectIDFromHex(profile.ID)
	limit, page := parseRawPagination(c)

	c.JSON(http.StatusOK, gin.H{"followings": h.fetchFollowersAggregate(c.Request.Context(), ownerID, limit, page, "followings")})
}

// GetIsFollowing checks if the current user follows a profile.
// GET /profile/:profileId/is-following
func (h *Handler) GetIsFollowing(c *gin.Context) {
	profileIDStr := c.Param("profileId")
	profileID, err := primitive.ObjectIDFromHex(profileIDStr)
	if err != nil {
		c.JSON(http.StatusUnprocessableEntity, gin.H{"error": "Invalid profile id!"})
		return
	}

	user := middleware.GetUser(c)
	userID, _ := primitive.ObjectIDFromHex(user.ID)

	ctx, cancel := context.WithTimeout(c.Request.Context(), 5*time.Second)
	defer cancel()

	count, _ := h.db.Collection(models.UsersCollection).CountDocuments(ctx, bson.M{"_id": profileID, "followers": userID})
	c.JSON(http.StatusOK, gin.H{"status": count > 0})
}

// GetRecommendByProfile returns recommended audios based on listening history.
// GET /profile/recommended
func (h *Handler) GetRecommendByProfile(c *gin.Context) {
	profile := middleware.GetUser(c)
	ownerID, _ := primitive.ObjectIDFromHex(profile.ID)

	ctx, cancel := context.WithTimeout(c.Request.Context(), 15*time.Second)
	defer cancel()

	categories := h.getUserCategories(ctx, ownerID)

	matchStage := bson.D{{Key: "_id", Value: bson.D{{Key: "$exists", Value: true}}}}
	if len(categories) > 0 {
		matchStage = bson.D{{Key: "category", Value: bson.D{{Key: "$in", Value: categories}}}}
	}

	pipeline := mongo.Pipeline{
		{{Key: "$match", Value: matchStage}},
		{{Key: "$sort", Value: bson.D{{Key: "likes", Value: -1}}}},
		{{Key: "$limit", Value: 10}},
		{{Key: "$lookup", Value: bson.D{
			{Key: "from", Value: "users"},
			{Key: "localField", Value: "owner"},
			{Key: "foreignField", Value: "_id"},
			{Key: "as", Value: "owner"},
		}}},
		{{Key: "$unwind", Value: "$owner"}},
		{{Key: "$project", Value: bson.D{
			{Key: "_id", Value: 0},
			{Key: "id", Value: "$_id"},
			{Key: "title", Value: 1},
			{Key: "about", Value: 1},
			{Key: "category", Value: 1},
			{Key: "file", Value: "$file.url"},
			{Key: "poster", Value: "$poster.url"},
			{Key: "owner", Value: bson.D{
				{Key: "name", Value: "$owner.name"},
				{Key: "id", Value: "$owner._id"},
			}},
		}}},
	}

	cursor, err := h.db.Collection(models.AudiosCollection).Aggregate(ctx, pipeline)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch recommendations"})
		return
	}
	defer cursor.Close(ctx)

	var audios []bson.M
	cursor.All(ctx, &audios) //nolint:errcheck
	if audios == nil {
		audios = []bson.M{}
	}
	c.JSON(http.StatusOK, gin.H{"audios": audios})
}

// --- Private helpers ---

func (h *Handler) getUserCategories(ctx context.Context, ownerID primitive.ObjectID) []string {
	thirtyDaysAgo := time.Now().AddDate(0, 0, -30)

	pipeline := mongo.Pipeline{
		{{Key: "$match", Value: bson.D{{Key: "owner", Value: ownerID}}}},
		{{Key: "$unwind", Value: "$all"}},
		{{Key: "$match", Value: bson.D{{Key: "all.date", Value: bson.D{{Key: "$gte", Value: thirtyDaysAgo}}}}}},
		{{Key: "$group", Value: bson.D{{Key: "_id", Value: "$all.audio"}}}},
		{{Key: "$lookup", Value: bson.D{
			{Key: "from", Value: "audios"},
			{Key: "localField", Value: "_id"},
			{Key: "foreignField", Value: "_id"},
			{Key: "as", Value: "audioData"},
		}}},
		{{Key: "$unwind", Value: "$audioData"}},
		{{Key: "$group", Value: bson.D{
			{Key: "_id", Value: nil},
			{Key: "category", Value: bson.D{{Key: "$addToSet", Value: "$audioData.category"}}},
		}}},
	}

	cursor, err := h.db.Collection(models.HistoriesCollection).Aggregate(ctx, pipeline)
	if err != nil {
		return nil
	}
	defer cursor.Close(ctx)

	type result struct {
		Category []string `bson:"category"`
	}
	var results []result
	cursor.All(ctx, &results) //nolint:errcheck

	if len(results) > 0 {
		return results[0].Category
	}
	return nil
}

func (h *Handler) fetchFollowersAggregate(ctx context.Context, userID primitive.ObjectID, limit, page int64, field string) []bson.M {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	pipeline := mongo.Pipeline{
		{{Key: "$match", Value: bson.D{{Key: "_id", Value: userID}}}},
		{{Key: "$project", Value: bson.D{
			{Key: field, Value: bson.D{
				{Key: "$slice", Value: bson.A{"$" + field, page * limit, limit}},
			}},
		}}},
		{{Key: "$unwind", Value: "$" + field}},
		{{Key: "$lookup", Value: bson.D{
			{Key: "from", Value: "users"},
			{Key: "localField", Value: field},
			{Key: "foreignField", Value: "_id"},
			{Key: "as", Value: "userInfo"},
		}}},
		{{Key: "$unwind", Value: "$userInfo"}},
		{{Key: "$group", Value: bson.D{
			{Key: "_id", Value: nil},
			{Key: field, Value: bson.D{{Key: "$push", Value: bson.D{
				{Key: "id", Value: "$userInfo._id"},
				{Key: "name", Value: "$userInfo.name"},
				{Key: "avatar", Value: "$userInfo.avatar.url"},
			}}}},
		}}},
	}

	cursor, err := h.db.Collection(models.UsersCollection).Aggregate(ctx, pipeline)
	if err != nil {
		return []bson.M{}
	}
	defer cursor.Close(ctx)

	type aggregateResult struct {
		Data []bson.M `bson:"followers"`
	}
	var results []bson.M
	cursor.All(ctx, &results) //nolint:errcheck

	if len(results) == 0 {
		return []bson.M{}
	}

	if data, ok := results[0][field].(primitive.A); ok {
		out := make([]bson.M, len(data))
		for i, v := range data {
			if m, ok := v.(bson.M); ok {
				out[i] = m
			}
		}
		return out
	}
	return []bson.M{}
}

func parsePagination(c *gin.Context) (skip, limit int64) {
	lim, _ := strconv.ParseInt(c.DefaultQuery("limit", "20"), 10, 64)
	page, _ := strconv.ParseInt(c.DefaultQuery("pageNumber", "0"), 10, 64)
	if lim <= 0 {
		lim = 20
	}
	return page * lim, lim
}

func parseRawPagination(c *gin.Context) (limit, page int64) {
	limit, _ = strconv.ParseInt(c.DefaultQuery("limit", "20"), 10, 64)
	page, _ = strconv.ParseInt(c.DefaultQuery("pageNumber", "0"), 10, 64)
	if limit <= 0 {
		limit = 20
	}
	return
}
